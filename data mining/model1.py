# -*- coding: utf-8 -*-
"""mostusefuldata.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1To0Bu9UYdbpTwa3jaePXmn2IWApqfGTT

# **ADATHALMAZ ELŐKÉSZÍTÉS**

---

Kezdetben készítettem scrapet különböző oldalaktól és kiválaszottam azt, ahol a legtöbb olyan rekord volt, amiben helyes adatok szerepelnek. Helyes adatnak vettem azt, ha a sorban nem volt olyan attribútum, ami nem tartalmaz értéket vagy az érték helytelen értéket vett fel(például, ha a labdabirtoklás összértéke nem 100% vagy ha a BET365 adatok által kiadott eseménytér túlságon eltér egy teljes eseménytértől).
"""

import numpy as np
import os
import tensorflow as tf
assert tf.__version__.startswith('2')

'''physical_devices = tf.config.experimental.list_physical_devices('GPU')
print("Num GPUs Available: ", len(physical_devices))
tf.config.experimental.set_memory_growth(physical_devices[0], True)'''

from google.colab import drive

drive.mount('/content/drive')

import pandas as pd

data = pd.read_csv('/content/drive/MyDrive/aszakdoga/data/dataset4.csv')

data.head()

"""A futtatókörnyezet után a scrapeből hátramaradt linkeket tartalmazó sorokat kitöröltem"""

list(data.columns)

data.isnull().sum()

"""**Felesleges oszlopok kiszedése**

---

Továbbá eldobtam az összes üres mezőt tartalmazó sort(talán 1 meccset veszítettem ezzel)
"""

data = data.drop(['web-scraper-order', 'web-scraper-start-url', 'extract_matches','extract_matches-href','matches-href','stats-href','stats','betlink','betlink-href' ],
          axis='columns')

data.shape

data = data.dropna(thresh=400 , axis='columns')

data.shape

data.isnull().sum()

data = data.dropna()

data.shape

data.isnull().sum()

data = data.drop_duplicates()

data.shape

"""Meggyőződtem, hogy a statisztikák valós tartományok között mozognak"""

useful = data[
     (1 / data['bethomewinodds'] + 1 / data['betguestwinodds'] + 1 / data['betdrawodds'] >0.7) &
     (1 / data['bethomewinodds'] + 1 / data['betguestwinodds'] + 1 / data['betdrawodds'] < 1.1)
]

useful.to_numpy

useful.head()

useful.shape

df = useful
df.head(5)

"""# **+ OSZLOPOK HOZZÁADÁSA**

---

Az adathalmaz nem tartalmazott pár alapvető értéket, ami kikövetkeztethető az adatokból, mint például a gólkülönbség vagy a ki a győztes csapat.
"""

df = df.assign(GoalDiff=lambda x: x.homegoals - x.guestgoals)
#Ha a győztes a hazai, az érték 1 lesz
#Ha a győztes a vendég, az érték -1 lesz
#Ha döntetlen, az érték 0 lesz
conditions = [
    (df['GoalDiff'] > 0),
    (df['GoalDiff'] == 0),
    (df['GoalDiff'] < 0)
    ]
values = [1,0,-1]
df['winner'] = np.select(conditions, values)
df.head(5)

#hibás értékek eltávolítása
df.drop('homeoffsides', axis='columns', inplace=True)
df.drop('guestoffsides', axis='columns', inplace=True)
df.head(5)

df.head(5)

#% levétel labdabirtoklásból
df['homepossession'] = df['homepossession'].map(lambda x: x.rstrip('%')).astype(float)
df['guestpossession'] = df['guestpossession'].map(lambda x: x.rstrip('%')).astype(float)
df.head(5)

df.info()

#df['winner'] = df['winner'].astype(float)
#df.info()

print(df['hometeamname'].unique())

"""# **Adatvizualizáció**

---

https://www.kaggle.com/alexisbcook/hello-seaborn
https://jakevdp.github.io/PythonDataScienceHandbook/05.08-random-forests.html
"""

def visualize_classifier(model, X, y, ax=None, cmap='rainbow'):
    ax = ax or plt.gca()
    
    # Plot the training points
    ax.scatter(X[:, 0], X[:, 1], c=y, s=30, cmap=cmap,
               clim=(y.min(), y.max()), zorder=3)
    ax.axis('tight')
    ax.axis('off')
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    
    # fit the estimator
    model.fit(X, y)
    xx, yy = np.meshgrid(np.linspace(*xlim, num=200),
                         np.linspace(*ylim, num=200))
    Z = model.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)

    # Create a color plot with the results
    n_classes = len(np.unique(y))
    contours = ax.contourf(xx, yy, Z, alpha=0.3,
                           levels=np.arange(n_classes + 1) - 0.5,
                           cmap=cmap, clim=(y.min(), y.max()),
                           zorder=1)

    ax.set(xlim=xlim, ylim=ylim)

# Commented out IPython magic to ensure Python compatibility.
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
print("Setup Complete")

plt.figure(figsize=(16,6))

sns.swarmplot(x=df['GoalDiff'],
              y=df['homeshotsongoal'])

plt.figure(figsize=(16,6))

sns.swarmplot(x=df['GoalDiff'],
              y=df['homeshotsongoal']+df['homeshotsoffgoal'])

plt.figure(figsize=(16,10))
sns.swarmplot(x=df['winner'],
              y=df['homepossession'])

plt.figure(figsize=(16,10))
sns.distplot(a=df['winner'], kde=False)

import matplotlib.pyplot as plt
import numpy as np
plt.figure(figsize=(15,15))
plt.subplot(3,3,1)
sns.regplot(x=df['GoalDiff'], y=df['homepossession'])

plt.subplot(3,3,2)
sns.regplot(x=df['GoalDiff'], y=df['homegoalattempts'])

plt.subplot(3,3,3)
sns.regplot(x=df['GoalDiff'], y=df['homeshotsongoal'])

plt.subplot(3,3,4)
sns.regplot(x=df['GoalDiff'], y=df['homeshotsoffgoal'])

plt.subplot(3,3,5)
sns.regplot(x=df['GoalDiff'], y=df['homeblockedshots'])

plt.subplot(3,3,6)
sns.regplot(x=df['GoalDiff'], y=df['homefreekicks'])

plt.subplot(3,3,7)
sns.regplot(x=df['GoalDiff'], y=df['homecornerkicks'])

plt.subplot(3,3,8)
sns.regplot(x=df['GoalDiff'], y=df['bethomewinodds'])

plt.subplot(3,3,9)
sns.regplot(x=df['GoalDiff'], y=df['homethrowin'])

plt.figure(figsize=(20,20))
sns.set(font_scale=2.2)
plt.subplot(2,2,1)
ax1 = sns.regplot(x=df['GoalDiff'], y=df['homecornerkicks'])
ax1.set_xlabel("Gólkülönbség",fontsize=30)
ax1.set_ylabel("Szögletek száma",fontsize=30)

plt.subplot(2,2,2)
ax2 = sns.regplot(x=df['GoalDiff'], y=df['homepossession'])
ax2.set_xlabel("Gólkülönbség",fontsize=30)
ax2.set_ylabel("Labdabirtoklás",fontsize=30)

plt.subplot(2,2,3)
ax3 = sns.regplot(x=df['GoalDiff'], y=df['homegoalattempts'])
ax3.set_xlabel("Gólkülönbség száma",fontsize=30)
ax3.set_ylabel("Lövések száma",fontsize=30)

plt.subplot(2,2,4)
ax4 = sns.regplot(x=df['GoalDiff'], y=df['homeshotsongoal'])
ax4.set_xlabel("Gólkülönbség",fontsize=30)
ax4.set_ylabel("Kaput találó lövések száma",fontsize=30)

plt.figure(figsize=(15,15))
ax = sns.regplot(x=df['GoalDiff'], y=df['homeshotsongoal']-df['guestshotsongoal'])
ax.set(xlabel='Gólkülönbség', ylabel='Kaput találó lövések száma')

"""Melyik diagramot érdemes választani?
https://www.kaggle.com/alexisbcook/choosing-plot-types-and-custom-styles

# **KorrelációVizsgálat**

---
"""

correlation_df = df.corr()

correlation_df.loc[:, ['GoalDiff']]
''''def corrhome(value)
def corrdraw(value)
def corrguest(value)
def calcvalue(idx):
  value = df.loc[idx, homepossession]
  value +=df.loc[idx, guestpossession]
  value +=df.loc[idx, homegoalattempts]
  value +=df.loc[idx, guestgoalattempts]
  value +=df.loc[idx, homeshotsongoal]
  value +=df.loc[idx, guestshotsongoal]
  value +=df.loc[idx, homeshotsoffgoal]
  value +=df.loc[idx, homeblockedshots]
  value +=df.loc[idx, guestshotsoffgoal]
  value +=df.loc[idx, guestblockedshots]
  value +=df.loc[idx, homefreekicks]
  value +=df.loc[idx, guestfreekicks]
  value +=df.loc[idx, homecornerkicks]
  value +=df.loc[idx, guestcornerkicks]
  value +=df.loc[idx, guestshotsoffgoal]
  #corrHomeOdds corrDrawOdds corrGuestOdds
for idx in df.index:
  value = calcvalue(idx)
  corrhome(value)
  corrdraw(value)
  corrguest(value)'''

plt.figure(figsize=(30,30))
sns.heatmap(correlation_df, annot=True)
plt.show()

'''plt.rcdefaults()
fig, ax = plt.subplots()

y_pos = np.arange(len(df.GoalDiff))

ax.barh(y_pos, df.homegoalattempts, align='center')
ax.set_yticks(y_pos)
ax.set_yticklabels(df.GoalDiff)
ax.invert_yaxis()  # labels read top-to-bottom
ax.set_xlabel('hazai próbálkozás')
ax.set_title('Gól/hazai próbálkozás korreláció')'''

'''unigd = df['GoalDiff'].unique().tolist()
uniha = df['homegoalattempts'].unique().tolist()
unigd.sort()
uniha.sort()

print(unigd)'''

#for row in useful.rows:

"""# **adathalmaz kiegyensúlyozása**

---

oversampling(Smote) https://towardsdatascience.com/having-an-imbalanced-dataset-here-is-how-you-can-solve-it-1640568947eb
https://towardsdatascience.com/5-smote-techniques-for-oversampling-your-imbalance-data-b8155bdbe2b5
"""

from imblearn.over_sampling import SMOTE

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]

sm = SMOTE(sampling_strategy='auto', random_state=7)

trainX, trainY = sm.fit_resample(X, y)

df_oversampler = pd.DataFrame(trainX, columns = [
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'])
df_oversampler['winner'] = trainY

df_oversampler.head(5)

plt.figure(figsize=(16,10))
sns.distplot(a=df_oversampler['winner'], kde=False)

sns.set(font_scale=2.4)

plt.figure(figsize=(20,10))
plt.subplot(1,2,1)
a1 = df.winner.value_counts().sort_values().plot.bar()
plt.title("SMOTE előtt",fontsize=40)
plt.xlabel("Győztes",fontsize=30)
plt.ylabel("Előfordulás",fontsize=30)
plt.show(block=True)

plt.figure(figsize=(20,10))
plt.subplot(1,2,2)
plt.xticks(rotation=90)
a2 = df_oversampler.winner.value_counts().sort_values().plot.bar()
plt.title("SMOTE után",fontsize=40)
plt.xlabel("Győztes",fontsize=30)
plt.ylabel("Előfordulás",fontsize=30)
plt.show(block=True)

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

from sklearn.model_selection import train_test_split

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **SKÁLÁZÁS**

---


"""

from sklearn.preprocessing import StandardScaler

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

##train test halmaz kiválasztása
#X = df.loc[:,[
#              'PossessionDiff', 'GoalattemptsDiff', 'ShotsongoalDiff',
#       'ShotsoffgoalDiff', 'BlockedshotsDiff', 'CornerkicksDiff'
#              ]]
#y = df.loc[:,['winner']]
#print(X)
#print(y)

X_train_s = scaler.fit_transform(X_train)
X_test_s = scaler.transform(X_test)
X_train_s

"""# **Feature Selection**

---

https://www.youtube.com/watch?v=pcZ4YlvhSKU&ab_channel=KGPTalkie
"""

from numpy import std
from numpy import mean
from sklearn.tree import DecisionTreeClassifier
from sklearn.pipeline import Pipeline
from sklearn.datasets import make_classification
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.feature_selection import RFE
from sklearn.feature_selection import SelectFromModel
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

RFEresults = []
def run_randomForest(X_train,X_test ,y_train,y_test,index):
  clf = RandomForestClassifier(n_estimators=20, random_state=0, n_jobs= -1)
  clf.fit(X_train, y_train)
  y_pred = clf.predict(X_test)
  print('Accuracy: ', accuracy_score(y_test, y_pred))
  RFEresults.append(accuracy_score(y_test, y_pred))

rfe = RFE(estimator=DecisionTreeClassifier(), n_features_to_select=12)
model = DecisionTreeClassifier()
pipeline = Pipeline(steps=[('s',rfe),('m',model)])
cv = RepeatedStratifiedKFold(n_splits=5, n_repeats=3, random_state=1)
n_scores = cross_val_score(pipeline, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
n_scores

print('Accuracy: %.3f (%.3f)' % (mean(n_scores), std(n_scores)))

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

"""SelectFromModel módszerrel"""

sel = SelectFromModel(RandomForestClassifier(n_estimators=100, random_state=0, n_jobs= -1))
sel.fit(X_train, y_train)
#random forrest után melyikeket találta hasznosnak(true)
sel.get_support()

len(sel.get_support())

#random forrest után melyikeket találta hasznosnak
features = X_train.columns[sel.get_support()]
features

np.mean(sel.estimator_.feature_importances_)

sel.estimator_.feature_importances_

X_train.columns

"""**RFE**"""

sel = RFE(RandomForestClassifier(n_estimators=100, random_state=0, n_jobs= -1), n_features_to_select=8)
sel.fit(X_train, y_train)

sel.get_support()

features = X_train.columns[sel.get_support()]
features

"""**Feature selection by GradientBoost Tree Importance**"""

from sklearn.ensemble import GradientBoostingClassifier

#Hosszú fv a RFE tesztelésre, hogy hány attr a legalkalmasabb
for index in range(2,8):
  sel = RFE(GradientBoostingClassifier(n_estimators=100, random_state=0), n_features_to_select=index)
  sel.fit(X_train, y_train)
  X_train_rfe = sel.transform(X_train)
  X_test_rfe = sel.transform(X_test)
  print('Selected features?', index)
  run_randomForest(X_train_rfe,X_test_rfe,y_train,y_test,index)
  print()

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Df-feltöltéshez)**

---


"""

df.isnull().sum()

#train test halmaz kiválasztása
X_df = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y_df = df.loc[:,['winner']]
print(X)
print(y)

"""# **MODELLKÉSZÍTÉS**

---


"""

from sklearn import tree
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LinearRegression

from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification

"""# **RandomForestClassifier 2(RFE felhasználás)**"""

sel.score(X_test, y_test)

df_t = pd.DataFrame(df)
df_t.head()

sel_model_pred = sel.predict_proba(X)
sel_model_pred
sel_model_fpred = sel.predict(X)

dfhelp = pd.DataFrame(sel_model_pred)
dfhelp.info()

df_t['PredictedHomeOdds'] = 1/dfhelp[2]
df_t['PredictedDrawOdds'] = 1/dfhelp[1]
df_t['PredictedGuestOdds'] = 1/dfhelp[0]

df_t.head(20)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'PredictedHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

money_history[-1]

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **DecisionTreeClassifier**

---


"""

dtc_model = DecisionTreeClassifier(random_state=0)

dtc_model.fit(X_train,y_train)

dtc_model.score(X_test, y_test)

path = dtc_model.cost_complexity_pruning_path(X_train, y_train)
ccp_alphas = path.ccp_alphas
ccp_aplhas = ccp_alphas[:-1]

clf_dts = []

for ccp_alpha in ccp_alphas:
    dtc_model = DecisionTreeClassifier(random_state = 0, ccp_alpha =ccp_alpha)
    dtc_model.fit(X_train, y_train)
    clf_dts.append(dtc_model)

alpha_loop_values = []

for ccp_alpha in ccp_alphas:
    dtc_model = DecisionTreeClassifier(random_state = 0, ccp_alpha =ccp_alpha)
    scores = cross_val_score(dtc_model, X_train, y_train, cv=5)
    alpha_loop_values.append([ccp_alpha, np.mean(scores), np.std(scores)])
    
alpha_results = pd.DataFrame(alpha_loop_values,
                             columns=['alpha', 'mean_accuracy', 'std'])

alpha_results.plot(x='alpha',
                  y= 'mean_accuracy',
                   yerr = 'std',
                  marker ='o',
                  linestyle= '--',
                   figsize=(20,14))

alpha_results.mean_accuracy.max()

dtc_model = DecisionTreeClassifier(ccp_alpha = 0)
dtc_model = dtc_model.fit(X_train, y_train)

dtc_model_pred = dtc_model.predict_proba(X_df)
dtc_model_pred
dtcmodel_fpred = dtc_model.predict(X_df)

dtc_dfhelp = pd.DataFrame(dtc_model_pred)
dtc_dfhelp.info()

df_t['PredictedHomeOdds'] = 1/dtc_dfhelp[2]
df_t['PredictedDrawOdds'] = 1/dtc_dfhelp[1]
df_t['PredictedGuestOdds'] = 1/dtc_dfhelp[0]
df_t['PredictedWinner'] = dtcmodel_fpred

df_t.head(20)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'PredictedHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **LinearRegression**

---


"""

#.values will give the values in an array. (shape: (n,1)
#.ravel will convert that array shape to (n, )
linearr_model = LinearRegression()
linearr_model.fit(X_train,y_train)

linearr_model.score(X_test, y_test)

linearr_model.score(X_train,y_train)

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **LogisticRegression**

---


"""

#.values will give the values in an array. (shape: (n,1)
#.ravel will convert that array shape to (n, )
lr_model = LogisticRegression(multi_class = 'multinomial', random_state=42)
lr_model.fit(X_train,y_train.values.ravel())

lr_model.score(X_test, y_test)

lr_model_pred = lr_model.predict_proba(X)
lr_model_pred

dfhelp = pd.DataFrame(lr_model_pred)
dfhelp.info()

df['PredictedHomeOdds'] = dfhelp[2].map(lambda x: 1/x).astype(float)
df['PredictedDrawOdds'] = dfhelp[1].map(lambda x: 1/x).astype(float)
df['PredictedGuestOdds'] = dfhelp[0].map(lambda x: 1/x).astype(float)

df.head(10)

import matplotlib.pyplot as plt

print(X.size)
print(y.size)

y_pred = lr_model.predict(X_test)
from sklearn.metrics import confusion_matrix

cm = confusion_matrix(y_test,y_pred)

import seaborn as sn
plt.figure(figsize=(10,7))
sn.heatmap(cm,annot=True)
plt.xlabel('Predicted')
plt.ylabel('True value')

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'PredictedHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

money_history[-1]

#modell készítés vendég győzelemhez és adathalmaz feltöltés 
"""          X = df.drop(['matches','hometeamname','guestteamname','date','bethomewinodds','betdrawodds','betguestwinodds'], axis =1).copy()
          y = df.loc[:,['betguestwinodds']]
          X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
          model = DecisionTreeRegressor()
          model.fit(X_train,y_train)

          Guestrawpred = model.predict(X)
          df['Guestrawpred'] = Guestrawpred
          df.head()"""

#sportfogadóiroda által levett odds százalékos arányban 
"""def calcBeteventspace(a, b, c):
    eventspace = 1/a + 1/b +1/c
    return 1 / eventspace

beteventarray = df.apply(lambda row: calcBeteventspace(row['bethomewinodds'],row['betdrawodds'],row['betguestwinodds']),axis = 1)
meanBeteventspace = np.mean(beteventarray)
meanBeteventspace"""

#helyes oddsok kiszámolása
"""def correctodds(a, b, c, d):
    teljesesemenyter = 1/a + 1/b +1/c
    corrodds =1/((1/d) / teljesesemenyter)
    return corrodds * meanBeteventspace

df = df.assign(CurrectHomeOdds=lambda x: correctodds(x.Homerawpred,x.Drawrawpred, x.Guestrawpred,x.Homerawpred))
df = df.assign(CurrectDrawOdds=lambda x: correctodds(x.Homerawpred,x.Drawrawpred, x.Guestrawpred,x.Drawrawpred))
df = df.assign(CurrectGuestOdds=lambda x: correctodds(x.Homerawpred,x.Drawrawpred, x.Guestrawpred,x.Guestrawpred))
df.head()"""

"""# **TRAIN TESZT KÉSZÍTÉS**

---

df_oversampler.isnull().sum()
"""

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              #'homeshotsoffgoal','guestshotsoffgoal',
              #'homeblockedshots','guestblockedshots',
              #'homefreekicks','guestfreekicks',
              #'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **K nearest neighbors**

---

https://www.youtube.com/watch?v=0BGLfYY26zQ&ab_channel=DataProfessor
"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import matthews_corrcoef

knn = KNeighborsClassifier(3) # Define classifier
knn.fit(X_train, y_train) # Train model

# Make predictions
y_train_pred = knn.predict(X_train)
y_test_pred = knn.predict(X_test)

# Training set performance
knn_train_accuracy = accuracy_score(y_train, y_train_pred) # Calculate Accuracy

# Test set performance
knn_test_accuracy = accuracy_score(y_test, y_test_pred) # Calculate Accuracy

print('Model performance for Training set')
print('- Accuracy: %s' % knn_train_accuracy)
print('----------------------------------')
print('Model performance for Test set')
print('- Accuracy: %s' % knn_test_accuracy)

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **Support vector machine**

---

https://www.youtube.com/watch?v=0BGLfYY26zQ&ab_channel=DataProfessor
"""

from sklearn.svm import SVC

svm_rbf = SVC(gamma=2, C=1)
svm_rbf.fit(X_train, y_train)

# Make predictions
y_train_pred = svm_rbf.predict(X_train)
y_test_pred = svm_rbf.predict(X_test)

# Training set performance
svm_rbf_train_accuracy = accuracy_score(y_train, y_train_pred) # Calculate Accuracy

# Test set performance
svm_rbf_test_accuracy = accuracy_score(y_test, y_test_pred) # Calculate Accuracy

print('Model performance for Training set')
print('- Accuracy: %s' % svm_rbf_train_accuracy)
print('----------------------------------')
print('Model performance for Test set')
print('- Accuracy: %s' % svm_rbf_test_accuracy)

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **Neural network - Sklearn**

---

https://www.youtube.com/watch?v=0BGLfYY26zQ&ab_channel=DataProfessor
"""

from sklearn.neural_network import MLPClassifier

mlp = MLPClassifier(alpha=1, max_iter=1000)
mlp.fit(X_train, y_train)

# Make predictions
y_train_pred = mlp.predict(X_train)
y_test_pred = mlp.predict(X_test)

#y_test_pred

# Training set performance
mlp_train_accuracy = accuracy_score(y_train, y_train_pred) # Calculate Accuracy

# Test set performance
mlp_test_accuracy = accuracy_score(y_test, y_test_pred) # Calculate Accuracy

print('Model performance for Training set')
print('- Accuracy: %s' % mlp_train_accuracy)
print('----------------------------------')
print('Model performance for Test set')
print('- Accuracy: %s' % mlp_test_accuracy)

"""# **TRAIN TESZT KÉSZÍTÉS**

---


"""

df.isnull().sum()

df = df.dropna(axis='columns')

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **Gradient Boosting**

---

https://www.youtube.com/watch?v=BVMa4nXjQCM&ab_channel=HarshKumar
"""

from sklearn.ensemble import GradientBoostingClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import roc_auc_score

model_gbm = GradientBoostingClassifier(n_estimators=5000,
                                       learning_rate=0.05,
                                       max_depth=3,
                                       subsample=0.5,
                                       validation_fraction=0.1,
                                       n_iter_no_change=20,
                                       max_features='log2',
                                       verbose=1)

model_gbm.fit(X_train, y_train)

len(model_gbm.estimators_)

y_train_pred = model_gbm.predict(X_train)
y_valid_pred = model_gbm.predict(X_test)

# Training set performance
mlp_train_accuracy = accuracy_score(y_train, y_train_pred) # Calculate Accuracy

# Test set performance
mlp_test_accuracy = accuracy_score(y_test, y_test_pred) # Calculate Accuracy

print('Model performance for Training set')
print('- Accuracy: %s' % mlp_train_accuracy)
print('----------------------------------')
print('Model performance for Test set')
print('- Accuracy: %s' % mlp_test_accuracy)

proba = model_gbm.predict_proba(X)

proba

df.head()

"""# **Exportálás**

---


"""

#exportálás
df.to_csv (r'D:\Desktop\aSzakdoga\models\cleareddf.csv')

#df2 létrehozás és exportálás
df2 = df.drop(['homepossession','guestpossession','homegoals','guestgoals','homegoalattempts','guestgoalattempts','homeshotsongoal','guestshotsongoal',
               'homeshotsoffgoal','guestshotsoffgoal','homeblockedshots','guestblockedshots','homefreekicks','guestfreekicks','homecornerkicks',
               'guestcornerkicks','homethrowin','guestthrowin'], axis =1).copy()
df2.to_csv (r'D:\Desktop\aSzakdoga\models\basicdf2.csv')

preddf = pd.DataFrame({'A': y_test, 'B': y_predicted}, index=y_test.index)
preddf

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

plt.figure(figsize = (15,5))
sns.jointplot(x=df['homegoals'], y=df['guestgoals'],  kind="kde")

df.head(5)

"""# **TRAIN TESZT KÉSZÍTÉS(original data)**

---


"""

df.isnull().sum()

for idx in df.index: 
  if df.loc[idx, 'winner'] == 1:
    df.loc[idx, 'HomeTeamWin'] = 1
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == 0:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 1
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == -1:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 1

df.head(10)

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['HomeTeamWin','Draw','GuestTeamWin']]
print(X)
print(y)

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled data)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

for idx in df_oversampler.index: 
  if df_oversampler.loc[idx, 'winner'] == 1:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 1
    df_oversampler.loc[idx, 'Draw'] = 0
    df_oversampler.loc[idx, 'GuestTeamWin'] = 0
  elif df_oversampler.loc[idx, 'winner'] == 0:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 0
    df_oversampler.loc[idx, 'Draw'] = 1
    df_oversampler.loc[idx, 'GuestTeamWin'] = 0
  elif df_oversampler.loc[idx, 'winner'] == -1:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 0
    df_oversampler.loc[idx, 'Draw'] = 0
    df_oversampler.loc[idx, 'GuestTeamWin'] = 1

df_oversampler.head(10)

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['HomeTeamWin','Draw','GuestTeamWin']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TENSORFLOW**

---

https://www.youtube.com/watch?v=6_2hzRopPbQ&ab_channel=NicholasRenotte
https://www.youtube.com/watch?v=bqBRET7tbiQ&ab_channel=DigitalSreeni
"""

from tensorflow import keras
from tensorflow import lite

from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from sklearn.metrics import accuracy_score

from sklearn.preprocessing import MinMaxScaler

scaler_mm = MinMaxScaler()
#scaler_mm.fit(X)
X = scaler_mm.fit_transform(X)
X

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,random_state = 42, stratify = y)

neuralmodel = Sequential()
neuralmodel.add(Dense(3))

neuralmodel.compile(loss='mean_squared_error', optimizer='sgd')
print(neuralmodel.summary)

neuralmodel.fit(X_train, y_train, verbose = 1, epochs=180, validation_data=(X_test, y_test))

y_hat = neuralmodel.predict(X_test)
y_hat

y_hat = pd.DataFrame(y_hat, columns = ['hometeam','draw','guest'])
y_hat.head()

for idx in y_hat.index: 
  if y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'draw'] and y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 1
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 1
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'draw']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 1

y_hat.head()

accuracy_score(y_test, y_hat)

"""

---

"""

X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
X = scaler_mm.fit_transform(X)

dfhelp = neuralmodel.predict(X)
dfhelp = pd.DataFrame(dfhelp, columns = ['Homepredodds','Drawpredodds','Guestpredodds'])
home = dfhelp['Homepredodds']

print(dfhelp['Homepredodds'].max())
print(dfhelp['Homepredodds'].min())
print(dfhelp['Drawpredodds'].max())
print(dfhelp['Drawpredodds'].min())
print(dfhelp['Guestpredodds'].max())
print(dfhelp['Guestpredodds'].min())



df['PredictedHomeOdds'] = dfhelp['Homepredodds'].map(lambda x: 1/x).astype(float)
df['PredictedDrawOdds'] = dfhelp['Drawpredodds'].map(lambda x: 1/x).astype(float)
df['PredictedGuestOdds'] = dfhelp['Guestpredodds'].map(lambda x: 1/x).astype(float)

df.head(10)

neural_df = df

#helyes oddsok kiszámolása
def correctodds(a, b, c, d):
    teljesesemenyter = 1/a + 1/b +1/c
    corrodds =1/((1/d) / teljesesemenyter)
    return corrodds

df = df.assign(CurrectHomeOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedHomeOdds))
df = df.assign(CurrectDrawOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedDrawOdds))
df = df.assign(CurrectGuestOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedGuestOdds))
df.head()

df.to_csv("neuralpred_data1.csv")

df.drop(['PredictedHomeOdds','PredictedDrawOdds','PredictedGuestOdds','PredictedWinner','HomeTeamWin','Draw','GuestTeamWin'],axis='columns', inplace=True)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'CurrectHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betdrawodds'] > df.loc[idx, 'CurrectDrawOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 0:
      betwin = 0.25 * money * df.loc[idx, 'betdrawodds']
    elif df.loc[idx, 'winner'] != 0:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betguestwinodds'] > df.loc[idx, 'CurrectGuestOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == -1:
      betwin = 0.25 * money * df.loc[idx, 'betguestwinodds']
    elif df.loc[idx, 'winner'] != -1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

money_history

"""

---

"""

#model = keras.Sequential([keras.layers.Dense(units=1,input_shape=[1]), keras.layers.Dense(units=1,input_shape=[1])])

#model.compile(optimizer='sgd', loss='mean_squared_error')

#model.fit(X, y, epochs=100)

#print(model.predict([0]))

#kearas_file = "homeoddstest.h5"

#tf.keras.models.save_model(model, kearas_file)

#converter = lite.TFLiteConverter.from_keras_model(model)

#tfmodel = converter.convert()

#print(tfmodel.predict([0]))

"""# **TRAIN TESZT KÉSZÍTÉS(original data)**

---


"""

df.isnull().sum()

df = df.dropna()

for idx in df.index: 
  if df.loc[idx, 'winner'] == 1:
    df.loc[idx, 'HomeTeamWin'] = 1
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == 0:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 1
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == -1:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 1

df.head(10)

#train test halmaz kiválasztása
X = df.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              #'homeshotsoffgoal','guestshotsoffgoal',
              #'homeblockedshots','guestblockedshots',
              #'homefreekicks','guestfreekicks',
              #'homecornerkicks','guestcornerkicks'
              ]]
y = df.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled)**

---


"""

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              #'hometeamname','guestteamname',
              'homepossession','guestpossession',
              #'homegoals','guestgoals',
              'homegoalattempts','guestgoalattempts',
              'homeshotsongoal','guestshotsongoal',
              'homeshotsoffgoal','guestshotsoffgoal',
              'homeblockedshots','guestblockedshots',
              'homefreekicks','guestfreekicks',
              'homecornerkicks','guestcornerkicks'
              ]]
y = df_oversampler.loc[:,['winner']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **Stacking**

---

https://www.youtube.com/watch?v=0BGLfYY26zQ&ab_channel=DataProfessor
"""

# Define estimators
from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression

estimator_list = [
    ('rf',sel),
    ('lr',lr_model),
    ('mlp',mlp),
    ('knn', knn), ]

# Build stack model
stack_model = StackingClassifier(
    estimators=estimator_list, final_estimator=LogisticRegression()
)

# Train stacked model
stack_model.fit(X_train, y_train)

# Make predictions
y_train_pred = stack_model.predict(X_train)
y_test_pred = stack_model.predict(X_test)

# Training set model performance
stack_model_train_accuracy = accuracy_score(y_train, y_train_pred) # Calculate Accuracy
stack_model_train_mcc = matthews_corrcoef(y_train, y_train_pred) # Calculate MCC

# Test set model performance
stack_model_test_accuracy = accuracy_score(y_test, y_test_pred) # Calculate Accuracy
stack_model_test_mcc = matthews_corrcoef(y_test, y_test_pred) # Calculate MCC

print('Model performance for Training set')
print('- Accuracy: %s' % stack_model_train_accuracy)
print('- MCC: %s' % stack_model_train_mcc)
print('----------------------------------')
print('Model performance for Test set')
print('- Accuracy: %s' % stack_model_test_accuracy)
print('- MCC: %s' % stack_model_test_mcc)

stack_res = stack_model.predict_proba(X)
stack_res

dfhelp = pd.DataFrame(stack_res)
dfhelp.info()

df['PredictedHomeOdds'] = dfhelp[2].map(lambda x: 1/x).astype(float)
df['PredictedDrawOdds'] = dfhelp[1].map(lambda x: 1/x).astype(float)
df['PredictedGuestOdds'] = dfhelp[0].map(lambda x: 1/x).astype(float)

df.head(10)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'PredictedHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

money_history[-1]

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled data,Adatkülönbségekkel)**

---


"""

df.columns

df = df.assign(PossessionDiff=lambda x: x.homepossession - x.guestpossession)
df = df.assign(GoalattemptsDiff=lambda x: x.homegoalattempts - x.guestgoalattempts)
df = df.assign(ShotsongoalDiff=lambda x: x.homeshotsongoal - x.guestshotsongoal)
df = df.assign(ShotsoffgoalDiff=lambda x: x.homeshotsoffgoal - x.guestshotsoffgoal)
df = df.assign(BlockedshotsDiff=lambda x: x.homeblockedshots - x.guestblockedshots)
df = df.assign(CornerkicksDiff=lambda x: x.homecornerkicks - x.guestcornerkicks)

df.isnull().sum()

df = df.dropna(axis='columns')

for idx in df.index: 
  if df.loc[idx, 'winner'] == 1:
    df.loc[idx, 'HomeTeamWin'] = 1
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == 0:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 1
    df.loc[idx, 'GuestTeamWin'] = 0
  elif df.loc[idx, 'winner'] == -1:
    df.loc[idx, 'HomeTeamWin'] = 0
    df.loc[idx, 'Draw'] = 0
    df.loc[idx, 'GuestTeamWin'] = 1

df.head(10)

#train test halmaz kiválasztása
X = df.loc[:,[
              'PossessionDiff', 'GoalattemptsDiff', 'ShotsongoalDiff',
       'ShotsoffgoalDiff', 'BlockedshotsDiff', 'CornerkicksDiff'
              ]]
y = df.loc[:,['HomeTeamWin','Draw','GuestTeamWin']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **Adatv különbségekkel**

---

"""

plt.figure(figsize=(15,15))
plt.subplot(3,3,1)
sns.regplot(x=df['GoalDiff'], y=df['PossessionDiff'])

plt.subplot(3,2,2)
sns.regplot(x=df['GoalDiff'], y=df['GoalattemptsDiff'])

plt.subplot(3,2,3)
sns.regplot(x=df['GoalDiff'], y=df['ShotsongoalDiff'])

plt.subplot(3,2,4)
sns.regplot(x=df['GoalDiff'], y=df['ShotsoffgoalDiff'])

plt.subplot(3,2,5)
sns.regplot(x=df['GoalDiff'], y=df['BlockedshotsDiff'])

plt.subplot(3,2,6)
sns.regplot(x=df['GoalDiff'], y=df['CornerkicksDiff'])

sns.regplot(x=df['winner'], y=df['GoalDiff'])

"""# **TENSORFLOW**

---

https://www.youtube.com/watch?v=6_2hzRopPbQ&ab_channel=NicholasRenotte
https://www.youtube.com/watch?v=bqBRET7tbiQ&ab_channel=DigitalSreeni
"""

from tensorflow import keras
from tensorflow import lite

from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from sklearn.metrics import accuracy_score

from sklearn.preprocessing import MinMaxScaler

scaler_mm = MinMaxScaler()
#scaler_mm.fit(X)
X = scaler_mm.fit_transform(X)
X

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,random_state = 42, stratify = y)

neuralmodel_sig = Sequential()
neuralmodel_sig.add(Dense(units = 3, activation='sigmoid'))

neuralmodel_sig.compile(loss='mean_squared_error', optimizer='sgd')
print(neuralmodel_sig.summary)

neuralmodel_sig.fit(X_train, y_train, verbose = 1, epochs=400, validation_data=(X_test, y_test))

y_hat = neuralmodel_sig.predict(X_test)
y_hat

y_hat = pd.DataFrame(y_hat, columns = ['hometeam','draw','guest'])
y_hat.head()

for idx in y_hat.index: 
  if y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'draw'] and y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 1
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 1
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'draw']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 1

y_hat.head()

accuracy_score(y_test, y_hat)

"""

---

"""

dfhelp = neuralmodel_sig.predict(X)
dfhelp = pd.DataFrame(dfhelp, columns = ['Homepredodds','Drawpredodds','Guestpredodds'])

print(dfhelp['Homepredodds'].max())
print(dfhelp['Homepredodds'].min())
print(dfhelp['Drawpredodds'].max())
print(dfhelp['Drawpredodds'].min())
print(dfhelp['Guestpredodds'].max())
print(dfhelp['Guestpredodds'].min())

df['PredictedHomeOdds'] = dfhelp['Homepredodds'].map(lambda x: 1/x).astype(float)
df['PredictedDrawOdds'] = dfhelp['Drawpredodds'].map(lambda x: 1/x).astype(float)
df['PredictedGuestOdds'] = dfhelp['Guestpredodds'].map(lambda x: 1/x).astype(float)

df.head(10)

neural_df = df

#helyes oddsok kiszámolása
def correctodds(a, b, c, d):
    teljesesemenyter = 1/a + 1/b +1/c
    corrodds =1/((1/d) / teljesesemenyter)
    return corrodds

df = df.assign(CurrectHomeOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedHomeOdds))
df = df.assign(CurrectDrawOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedDrawOdds))
df = df.assign(CurrectGuestOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedGuestOdds))
df.head()

df.to_csv("neuralpred_data1.csv")

df.drop(['PredictedHomeOdds','PredictedDrawOdds','PredictedGuestOdds','PredictedWinner','HomeTeamWin','Draw','GuestTeamWin'],axis='columns', inplace=True)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'CurrectHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betdrawodds'] > df.loc[idx, 'CurrectDrawOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 0:
      betwin = 0.25 * money * df.loc[idx, 'betdrawodds']
    elif df.loc[idx, 'winner'] != 0:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betguestwinodds'] > df.loc[idx, 'CurrectGuestOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == -1:
      betwin = 0.25 * money * df.loc[idx, 'betguestwinodds']
    elif df.loc[idx, 'winner'] != -1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

"""

---

"""

#model = keras.Sequential([keras.layers.Dense(units=1,input_shape=[1]), keras.layers.Dense(units=1,input_shape=[1])])

#model.compile(optimizer='sgd', loss='mean_squared_error')

#model.fit(X, y, epochs=100)

#print(model.predict([0]))

#kearas_file = "homeoddstest.h5"

#tf.keras.models.save_model(model, kearas_file)

#converter = lite.TFLiteConverter.from_keras_model(model)

#tfmodel = converter.convert()

#print(tfmodel.predict([0]))

"""# **TRAIN TESZT KÉSZÍTÉS(Oversampled data,Adatkülönbségekkel)**

---


"""

df_oversampler.columns

df_oversampler = df_oversampler.assign(PossessionDiff=lambda x: x.homepossession - x.guestpossession)
df_oversampler = df_oversampler.assign(GoalattemptsDiff=lambda x: x.homegoalattempts - x.guestgoalattempts)
df_oversampler = df_oversampler.assign(ShotsongoalDiff=lambda x: x.homeshotsongoal - x.guestshotsongoal)
df_oversampler = df_oversampler.assign(ShotsoffgoalDiff=lambda x: x.homeshotsoffgoal - x.guestshotsoffgoal)
df_oversampler = df_oversampler.assign(BlockedshotsDiff=lambda x: x.homeblockedshots - x.guestblockedshots)
df_oversampler = df_oversampler.assign(CornerkicksDiff=lambda x: x.homecornerkicks - x.guestcornerkicks)

df_oversampler.isnull().sum()

df_oversampler = df_oversampler.dropna(axis='columns')

for idx in df_oversampler.index: 
  if df_oversampler.loc[idx, 'winner'] == 1:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 1
    df_oversampler.loc[idx, 'Draw'] = 0
    df_oversampler.loc[idx, 'GuestTeamWin'] = 0
  elif df_oversampler.loc[idx, 'winner'] == 0:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 0
    df_oversampler.loc[idx, 'Draw'] = 1
    df_oversampler.loc[idx, 'GuestTeamWin'] = 0
  elif df_oversampler.loc[idx, 'winner'] == -1:
    df_oversampler.loc[idx, 'HomeTeamWin'] = 0
    df_oversampler.loc[idx, 'Draw'] = 0
    df_oversampler.loc[idx, 'GuestTeamWin'] = 1

df_oversampler.head(10)

#train test halmaz kiválasztása
X = df_oversampler.loc[:,[
              'PossessionDiff', 'GoalattemptsDiff', 'ShotsongoalDiff',
       'ShotsoffgoalDiff', 'BlockedshotsDiff', 'CornerkicksDiff'
              ]]
y = df_oversampler.loc[:,['HomeTeamWin','Draw','GuestTeamWin']]
print(X)
print(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
print(X_train.size)
print(y_train.size)

X_train.info()

"""# **TENSORFLOW(1 köztes réteg)**

---

https://www.youtube.com/watch?v=6_2hzRopPbQ&ab_channel=NicholasRenotte
https://www.youtube.com/watch?v=bqBRET7tbiQ&ab_channel=DigitalSreeni
"""

from tensorflow import keras
from tensorflow import lite

from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from sklearn.metrics import accuracy_score

from sklearn.preprocessing import MinMaxScaler

scaler_mm = MinMaxScaler()
#scaler_mm.fit(X)
X = scaler_mm.fit_transform(X)
X

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,random_state = 42, stratify = y)

neuralmodel_2 = Sequential()
neuralmodel_2.add(Dense(units = 32, activation='relu', input_dim=X_train.shape[1]))
neuralmodel_2.add(Dense(units = 3, activation='sigmoid'))

neuralmodel_2.compile(loss='mean_squared_error', optimizer='sgd')
print(neuralmodel_2.summary)

neuralmodel_2.fit(X_train, y_train, verbose = 1, epochs=400, validation_data=(X_test, y_test))

y_hat = neuralmodel_2.predict(X_test)
y_hat

y_hat = pd.DataFrame(y_hat, columns = ['hometeam','draw','guest'])
y_hat.head()

for idx in y_hat.index: 
  if y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'draw'] and y_hat.loc[idx, 'hometeam'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 1
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'draw'] > y_hat.loc[idx, 'guest']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 1
    y_hat.loc[idx, 'guest'] = 0
  elif y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'hometeam'] and y_hat.loc[idx, 'guest'] > y_hat.loc[idx, 'draw']:
    y_hat.loc[idx, 'hometeam'] = 0
    y_hat.loc[idx, 'draw'] = 0
    y_hat.loc[idx, 'guest'] = 1

y_hat.head()

accuracy_score(y_test, y_hat)

"""

---

"""

X = df_oversampler.loc[:,[
              'PossessionDiff', 'GoalattemptsDiff', 'ShotsongoalDiff',
       'ShotsoffgoalDiff', 'BlockedshotsDiff', 'CornerkicksDiff'
              ]]
X = scaler_mm.fit_transform(X)

dfhelp = neuralmodel_2.predict(X)
dfhelp = pd.DataFrame(dfhelp, columns = ['Homepredodds','Drawpredodds','Guestpredodds'])

print(dfhelp['Homepredodds'].max())
print(dfhelp['Homepredodds'].min())
print(dfhelp['Drawpredodds'].max())
print(dfhelp['Drawpredodds'].min())
print(dfhelp['Guestpredodds'].max())
print(dfhelp['Guestpredodds'].min())

df_oversampler['PredictedHomeOdds'] = dfhelp['Homepredodds'].map(lambda x: 1/x).astype(float)
df_oversampler['PredictedDrawOdds'] = dfhelp['Drawpredodds'].map(lambda x: 1/x).astype(float)
df_oversampler['PredictedGuestOdds'] = dfhelp['Guestpredodds'].map(lambda x: 1/x).astype(float)

df_oversampler.head(10)

neural_df = df_oversampler

#helyes oddsok kiszámolása
def correctodds(a, b, c, d):
    teljesesemenyter = 1/a + 1/b +1/c
    corrodds =1/((1/d) / teljesesemenyter)
    return corrodds

ddf_oversamplerf = df_oversampler.assign(CurrectHomeOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedHomeOdds))
df_oversampler = df_oversampler.assign(CurrectDrawOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedDrawOdds))
df_oversampler = df_oversampler.assign(CurrectGuestOdds=lambda x: correctodds(x.PredictedHomeOdds,x.PredictedDrawOdds, x.PredictedGuestOdds,x.PredictedGuestOdds))
df_oversampler.head()

df.to_csv("neuralpred_data1.csv")

df.drop(['PredictedHomeOdds','PredictedDrawOdds','PredictedGuestOdds','PredictedWinner','HomeTeamWin','Draw','GuestTeamWin'],axis='columns', inplace=True)

money = 10000
money_history = []
for idx in df.index: 
  if df.loc[idx, 'bethomewinodds'] > df.loc[idx, 'CurrectHomeOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 1:
      betwin = 0.25 * money * df.loc[idx, 'bethomewinodds']
    elif df.loc[idx, 'winner'] != 1:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betdrawodds'] > df.loc[idx, 'CurrectDrawOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == 0:
      betwin = 0.25 * money * df.loc[idx, 'betdrawodds']
    elif df.loc[idx, 'winner'] != 0:
      betwin = 0
    money = money + betwin
    money_history.append(money)
  if df.loc[idx, 'betguestwinodds'] > df.loc[idx, 'CurrectGuestOdds'] :
    money = money * 0.8
    if df.loc[idx, 'winner'] == -1:
      betwin = 0.25 * money * df.loc[idx, 'betguestwinodds']
    elif df.loc[idx, 'winner'] != -1:
      betwin = 0
    money = money + betwin
    money_history.append(money)

"""

---

"""

#model = keras.Sequential([keras.layers.Dense(units=1,input_shape=[1]), keras.layers.Dense(units=1,input_shape=[1])])

#model.compile(optimizer='sgd', loss='mean_squared_error')

#model.fit(X, y, epochs=100)

#print(model.predict([0]))

#kearas_file = "homeoddstest.h5"

#tf.keras.models.save_model(model, kearas_file)

#converter = lite.TFLiteConverter.from_keras_model(model)

#tfmodel = converter.convert()

#print(tfmodel.predict([0]))

DTC 0.5322966507177034
LinearRegression 0.34
LR 0.638755980861244
K nearest 0.6375598086124402
SVM 0.32
NN - Sklearn 0.5598086124401914
Gradient Boosting 0.33
Tensor relu - 0.58
Stacked - 0.7057416267942583
Tensor sig - 0.4654605263157895
Tensor sig 2 réteg - 0.562200956937799

"""# **Eredmény**

---


"""

models_x = ['DTC','LinReg','LogReg','K-near','SVM','NN-Skl','GradBoost','Tens-re','Stacked','Tens-sig','Tens-sig2']
value_y = [
0.5322966507177034,
0.34,
0.638755980861244,
0.6375598086124402,
0.32,
0.5598086124401914,
0.33,
0.58,
0.7057416267942583,
0.4654605263157895,
0.562200956937799
]
plt.figure(figsize=(15,10))
sns.set(font_scale=1.5)
ax = sns.barplot(x=models_x, y = value_y,)
sns.set(font_scale=1.4)
ax.set_xlabel("Modell",fontsize=20)
ax.set_ylabel("Pontosság",fontsize=20)